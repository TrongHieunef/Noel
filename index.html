<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title> Gi√°ng Sinh </title>
    <style>
        :root {
            --xmas-red: #D32F2F;
            --xmas-green: #1B5E20;
            --xmas-gold: #FFD700;
        }
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; touch-action: none; }
        
        #ui-container {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            z-index: 100; pointer-events: none;
        }
        
        .badge {
            display: inline-block; background: rgba(0,0,0,0.8);
            border: 2px solid var(--xmas-gold); color: var(--xmas-gold);
            padding: 12px 25px; border-radius: 50px;
            font-size: clamp(14px, 4vw, 18px); 
            font-weight: bold; margin-bottom: 15px;
            text-transform: uppercase; letter-spacing: 1px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
            text-shadow: 0 0 10px var(--xmas-gold);
            pointer-events: auto;
        }

        .guide-text { 
            color: #eee; font-size: clamp(10px, 3vw, 14px); 
            margin-bottom: 20px; text-shadow: 0 2px 4px black; 
        }

        /* N√∫t b·∫•m */
        .btn-main {
            pointer-events: auto; cursor: pointer;
            background: linear-gradient(to bottom, #D32F2F, #8B0000); 
            color: white; border: 2px solid var(--xmas-gold);
            padding: 15px 45px; border-radius: 30px; 
            font-weight: 800; font-size: 18px;
            box-shadow: 0 0 30px rgba(211, 47, 47, 0.6);
            transition: 0.3s;
            margin: 5px;
        }
        .btn-main:hover { transform: scale(1.05); }
        
        #btnUpload { 
            background: linear-gradient(to bottom, #1B5E20, #0a2e0c);
            border-style: dashed;
        }

        #webcam-box {
            position: absolute; top: 20px; right: 20px;
            width: clamp(100px, 30vw, 150px); 
            height: clamp(80px, 25vw, 110px);
            border: 2px solid var(--xmas-red); border-radius: 12px;
            z-index: 100; background: #111; overflow: hidden; opacity: 0.7;
        }
        video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

        @media (orientation: portrait) {
            .guide-text b { display: block; margin-top: 5px; }
        }
    </style>
</head>
<body>

<div id="ui-container">
    <div id="status-card" class="badge">üéÑ GI√ÅNG SINH AN L√ÄNH üéÑ</div>
    <div class="guide-text">
        üñê <b>Bung tay:</b> Xem ·∫£nh | ‚ÜîÔ∏è <b>Qu√©t:</b> Xoay<br>
        üëå <b>Ch·ª•m:</b> Zoom | ‚úåÔ∏è <b>Ch·ªØ V:</b> I LOVE YOU
    </div>
    
    <input type="file" id="fileInput" multiple accept="image/*" style="display: none;">
    <button id="btnUpload" class="btn-main">üì∏ CH·ªåN 4 ·∫¢NH K·ª∂ NI·ªÜM</button>
    <button id="btnStart" class="btn-main" style="display: none;">B·∫ÆT ƒê·∫¶U TR·∫¢I NGHI·ªÜM</button>
</div>

<div id="webcam-box" style="display:none;">
    <video id="video" playsinline autoplay muted></video>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.145.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
    // --- C·∫§U H√åNH NH·∫†C ---
    const MUSIC_URL = "./audio.mp3"; 
    let bgMusic = new Audio(MUSIC_URL);
    bgMusic.loop = true; 
    bgMusic.volume = 0.8;

    // --- C·∫§U H√åNH THREE.JS ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    document.body.appendChild(renderer.domElement);

    const Y_OFFSET = 3;
    function adjustCamera() {
        const aspect = window.innerWidth / window.innerHeight;
        camera.position.set(0, 8, aspect < 1 ? 55 : 40);
    }
    adjustCamera();

    // --- HI·ªÜU ·ª®NG TUY·∫æT ---
    const snowCount = 1000;
    const snowGeo = new THREE.BufferGeometry();
    const snowPos = new Float32Array(snowCount * 3);
    for (let i = 0; i < snowCount; i++) {
        snowPos[i*3] = (Math.random() - 0.5) * 100;
        snowPos[i*3+1] = Math.random() * 60;
        snowPos[i*3+2] = (Math.random() - 0.5) * 100;
    }
    snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
    const snowMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.15, transparent: true, opacity: 0.8 });
    const snow = new THREE.Points(snowGeo, snowMat);
    scene.add(snow);

    // --- CH·ªÆ "I LOVE YOU" ---
    function createTextParticles(text, yOff) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 600; canvas.height = 100;
        ctx.fillStyle = 'white';
        ctx.font = 'Bold 60px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(text, 300, 70);
        const imageData = ctx.getImageData(0, 0, 600, 100).data;
        const pValues = [];
        for (let y = 0; y < 100; y += 3) {
            for (let x = 0; x < 600; x += 3) {
                if (imageData[(y * 600 + x) * 4] > 128) {
                    pValues.push((x - 300) * 0.1, (50 - y) * 0.1 + yOff, 0);
                }
            }
        }
        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pValues, 3));
        const mat = new THREE.PointsMaterial({ color: 0xFF69B4, size: 0.25, transparent: true, opacity: 0 });
        return new THREE.Points(geo, mat);
    }
    const lovePoints = createTextParticles("I LOVE YOU", 10);
    scene.add(lovePoints);

    // --- H·ªÜ TH·ªêNG C√ÇY TH√îNG H·∫†T ---
    const treeCount = 4500, starCount = 350, garlandCount = 1500;
    const totalParticles = treeCount + starCount + garlandCount;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(totalParticles * 3);
    const colors = new Float32Array(totalParticles * 3);
    const origins = new Float32Array(totalParticles * 3);
    const velocities = new Float32Array(totalParticles * 3);

    let idx = 0;
    for (let i = 0; i < treeCount; i++) {
        const h = Math.random() * 20, rBase = (20 - h) * 0.45, r = rBase * (0.85 + Math.random() * 0.3), a = Math.random() * Math.PI * 2;
        const x = Math.cos(a) * r, y = h - 5 + Y_OFFSET, z = Math.sin(a) * r;
        positions.set([x, y, z], idx * 3); origins.set([x, y, z], idx * 3);
        colors.set(Math.random() > 0.5 ? [0.05, 0.4, 0.15] : [0.1, 0.8, 0.2], idx * 3);
        velocities.set([(Math.random()-0.5)*1.2, (Math.random()-0.5)*1.2, (Math.random()-0.5)*1.2], idx * 3);
        idx++;
    }
    for (let i = 0; i < starCount; i++) {
        const r = Math.random() * 1.5, theta = Math.random() * Math.PI * 2, phi = Math.acos(2 * Math.random() - 1);
        const x = r * Math.sin(phi) * Math.cos(theta), y = r * Math.sin(phi) * Math.sin(theta) + 15.5 + Y_OFFSET, z = r * Math.cos(phi);
        positions.set([x, y, z], idx * 3); origins.set([x, y, z], idx * 3);
        colors.set([1, 0.9, 0], idx * 3); velocities.set([x*2.5, Math.random()*1.5, z*2.5], idx * 3);
        idx++;
    }
    for (let i = 0; i < garlandCount; i++) {
        const t = i / garlandCount, h = t * 20, r = (20 - h) * 0.48 + 0.3, angle = t * Math.PI * 2 * 12;
        const x = Math.cos(angle)*r, y = h-5+Y_OFFSET, z = Math.sin(angle)*r;
        positions.set([x, y, z], idx * 3); origins.set([x, y, z], idx * 3);
        const rand = Math.random();
        if(rand < 0.5) colors.set([1, 0.84, 0], idx * 3);
        else if(rand < 0.9) colors.set([1, 0.1, 0.1], idx * 3);
        else colors.set([1, 1, 1], idx * 3);
        velocities.set([(Math.random()-0.5)*3, (Math.random()-0.5)*3, (Math.random()-0.5)*3], idx * 3);
        idx++;
    }
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    const tree = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 0.22, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true }));
    scene.add(tree);

    // --- CANVAS T·∫†O VI·ªÄN K·∫∏O G·∫¨Y ---
    const candyCanvas = document.createElement('canvas');
    candyCanvas.width = 64; candyCanvas.height = 64;
    const ctxC = candyCanvas.getContext('2d');
    ctxC.fillStyle = '#FFFFFF'; ctxC.fillRect(0,0,64,64);
    ctxC.strokeStyle = '#D32F2F'; ctxC.lineWidth = 15;
    ctxC.beginPath(); ctxC.moveTo(0,0); ctxC.lineTo(64,64); ctxC.stroke();
    const candyTex = new THREE.CanvasTexture(candyCanvas);
    candyTex.wrapS = candyTex.wrapT = THREE.RepeatWrapping;
    candyTex.repeat.set(8, 8);

    // --- H·ªÜ TH·ªêNG QU·∫¢N L√ù ·∫¢NH UPLOAD ---
    const imgGroup = new THREE.Group();
    const imageMeshes = [];
    const fileInput = document.getElementById('fileInput');
    const btnUpload = document.getElementById('btnUpload');
    const btnStart = document.getElementById('btnStart');
    const textureLoader = new THREE.TextureLoader();

    btnUpload.addEventListener('click', () => fileInput.click());

    fileInput.addEventListener('change', function(e) {
        const files = e.target.files;
        if (files.length < 4) {
            alert("H√£y ch·ªçn √≠t nh·∫•t 4 t·∫•m ·∫£nh nh√©!");
            return;
        }

        // D·ªçn d·∫πp ·∫£nh c≈©
        imageMeshes.forEach(m => imgGroup.remove(m));
        imageMeshes.length = 0;

        Array.from(files).slice(0, 4).forEach((file, i) => {
            const reader = new FileReader();
            reader.onload = function(event) {
                const texture = textureLoader.load(event.target.result);
                createPolaroid(texture, i);
            };
            reader.readAsDataURL(file);
        });

        btnUpload.style.display = 'none';
        btnStart.style.display = 'inline-block';
    });

    function createPolaroid(texture, i) {
        const photoW = 6, photoH = 7.5;
        const pad = 0.4, btm = 1.6;

        const mesh = new THREE.Mesh(
            new THREE.PlaneGeometry(photoW, photoH),
            new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, opacity: 0 })
        );

        const frame = new THREE.Mesh(
            new THREE.PlaneGeometry(photoW + pad*2, photoH + pad + btm),
            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0 })
        );
        frame.position.set(0, -btm/2 + pad/2, -0.02);
        mesh.add(frame);

        const candyBorder = new THREE.Mesh(
            new THREE.PlaneGeometry(photoW + 0.2, photoH + 0.2),
            new THREE.MeshBasicMaterial({ map: candyTex, transparent: true, opacity: 0 })
        );
        candyBorder.position.z = -0.01;
        mesh.add(candyBorder);

        const txtCanvas = document.createElement('canvas');
        txtCanvas.width = 256; txtCanvas.height = 64;
        const tCtx = txtCanvas.getContext('2d');
        tCtx.fillStyle = '#D32F2F'; tCtx.font = 'italic Bold 28px Arial';
        tCtx.textAlign = 'center'; tCtx.fillText('Merry Xmas üéÑ', 128, 45);
        const txtTex = new THREE.CanvasTexture(txtCanvas);
        const txtMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(3, 0.75),
            new THREE.MeshBasicMaterial({ map: txtTex, transparent: true, opacity: 0 })
        );
        txtMesh.position.set(0, -photoH/2 - 0.6, 0.01);
        mesh.add(txtMesh);

        const angle = (i / 4) * Math.PI * 2;
        mesh.userData.basePos = new THREE.Vector3(Math.cos(angle) * 18, 6 + Y_OFFSET, Math.sin(angle) * 18);
        imageMeshes.push(mesh);
        imgGroup.add(mesh);
    }
    scene.add(imgGroup);

    // --- LOGIC ƒêI·ªÄU KHI·ªÇN ---
    let handData = { active: false, open: false, pinch: false, vSign: false, x: 0.5 };
    let anim = { explode: 0, zoom: 1, rot: 0, love: 0 };

    btnStart.addEventListener('click', function() {
        this.style.display = 'none';
        document.getElementById('webcam-box').style.display = 'block';
        bgMusic.play().catch(e => console.log("L·ªói nh·∫°c:", e));
        initCamera();
    });

    function renderLoop() {
        requestAnimationFrame(renderLoop);
        const time = Date.now() * 0.002;
        
        // Tuy·∫øt r∆°i
        const sArray = snow.geometry.attributes.position.array;
        for (let i = 0; i < snowCount; i++) {
            sArray[i*3+1] -= 0.04;
            if (sArray[i*3+1] < -5) sArray[i*3+1] = 50;
        }
        snow.geometry.attributes.position.needsUpdate = true;

        // Smooth animations
        anim.love += ((handData.vSign ? 1 : 0) - anim.love) * 0.1;
        anim.explode += ((handData.open && !handData.vSign ? 1 : 0) - anim.explode) * 0.06;
        anim.zoom += ((handData.pinch ? 2.2 : 1) - anim.zoom) * 0.1;
        anim.rot += (((handData.x - 0.5) * -Math.PI * 2.5) - anim.rot) * 0.1;

        // I Love You Effect
        lovePoints.material.opacity = anim.love;
        lovePoints.position.y = Math.sin(time) * 1.2; 
        lovePoints.scale.set(1 + anim.love*0.2, 1 + anim.love*0.2, 1);

        // Tree Explosion Effect
        const pArray = tree.geometry.attributes.position.array;
        const explodeFactor = anim.explode * 20;
        for (let i = 0; i < totalParticles; i++) {
            const i3 = i * 3;
            pArray[i3] = origins[i3] + velocities[i3] * explodeFactor;
            pArray[i3+1] = origins[i3+1] + velocities[i3+1] * explodeFactor;
            pArray[i3+2] = origins[i3+2] + velocities[i3+2] * explodeFactor;
        }
        tree.geometry.attributes.position.needsUpdate = true;
        tree.material.opacity = 1 - anim.love; 
        tree.rotation.y += 0.002;

        // Garland Blinking
        if (tree.geometry.attributes.color) {
            const cArr = tree.geometry.attributes.color.array;
            for(let i = treeCount; i < totalParticles; i++) {
                const i3 = i * 3;
                if(i % 5 === 0) cArr[i3] *= (0.95 + Math.sin(time*5)*0.05);
            }
            tree.geometry.attributes.color.needsUpdate = true;
        }

        // Polaroid Interaction
        imgGroup.rotation.y = anim.rot;
        let maxZ = -9999, facingMesh = null;
        imageMeshes.forEach(mesh => {
            mesh.position.lerp(handData.open && !handData.vSign ? mesh.userData.basePos : new THREE.Vector3(0, Y_OFFSET + 5, 0), 0.08);
            const z = mesh.getWorldPosition(new THREE.Vector3()).z;
            if (z > maxZ) { maxZ = z; facingMesh = mesh; }
        });

        imageMeshes.forEach(mesh => {
            mesh.lookAt(camera.position);
            let isFacing = (mesh === facingMesh && handData.open && !handData.vSign);
            let opacity = (isFacing ? 1 : 0.15) * anim.explode * (1 - anim.love);
            mesh.material.opacity = THREE.MathUtils.lerp(mesh.material.opacity, opacity, 0.1);
            mesh.children.forEach(child => child.material.opacity = mesh.material.opacity);
            
            let targetScale = (isFacing && handData.pinch) ? anim.zoom : 1;
            mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.05);
        });

        renderer.render(scene, camera);
    }
    renderLoop();

    // --- MEDIAPIPE HANDS ---
    function initCamera() {
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        
        hands.onResults((results) => {
            const status = document.getElementById('status-card');
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                handData.active = true;
                handData.x = lm[0].x;
                handData.open = Math.hypot(lm[12].x - lm[0].x, lm[12].y - lm[0].y) > 0.3;
                handData.pinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y) < 0.06;
                handData.vSign = lm[8].y < lm[6].y && lm[12].y < lm[10].y && lm[16].y > lm[14].y;

                if(handData.vSign) { status.innerText = "üíñ I LOVE YOU üíñ"; status.style.color = "#FF69B4"; }
                else if(handData.pinch) { status.innerText = "üîç ƒêANG ZOOM ·∫¢NH"; status.style.color = "#00FFFF"; }
                else if(handData.open) { status.innerText = "üñê BUNG ·∫¢NH POLAROID"; status.style.color = "#FFD700"; }
                else { status.innerText = "‚úä N·∫ÆM TAY ƒê·ªÇ THU C√ÇY"; status.style.color = "white"; }
            } else {
                handData.active = false;
                status.innerText = "üéÑ GI√ÅNG SINH AN L√ÄNH üéÑ";
                status.style.color = "#FFD700";
            }
        });
        const cam = new Camera(document.getElementById('video'), { 
            onFrame: async () => { await hands.send({image: document.getElementById('video')}); }, 
            width: 320, height: 240 
        });
        cam.start();
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight; 
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        adjustCamera();
    });
</script>

</body>
</html>
